// automatically generated by the FlatBuffers compiler, do not modify

/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */

import * as flatbuffers from 'flatbuffers';

import { Check } from '../../nanokv/packet/check.js';
import { Dequeue } from '../../nanokv/packet/dequeue.js';
import { Enqueue } from '../../nanokv/packet/enqueue.js';
import { Mutation } from '../../nanokv/packet/mutation.js';


export class AtomicWrite {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):AtomicWrite {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsAtomicWrite(bb:flatbuffers.ByteBuffer, obj?:AtomicWrite):AtomicWrite {
  return (obj || new AtomicWrite()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsAtomicWrite(bb:flatbuffers.ByteBuffer, obj?:AtomicWrite):AtomicWrite {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new AtomicWrite()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

checks(index: number, obj?:Check):Check|null {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? (obj || new Check()).__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) : null;
}

checksLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

mutations(index: number, obj?:Mutation):Mutation|null {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? (obj || new Mutation()).__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) : null;
}

mutationsLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

enqueues(index: number, obj?:Enqueue):Enqueue|null {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? (obj || new Enqueue()).__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) : null;
}

enqueuesLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

dequeues(index: number, obj?:Dequeue):Dequeue|null {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? (obj || new Dequeue()).__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) : null;
}

dequeuesLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

static startAtomicWrite(builder:flatbuffers.Builder) {
  builder.startObject(4);
}

static addChecks(builder:flatbuffers.Builder, checksOffset:flatbuffers.Offset) {
  builder.addFieldOffset(0, checksOffset, 0);
}

static createChecksVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startChecksVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addMutations(builder:flatbuffers.Builder, mutationsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(1, mutationsOffset, 0);
}

static createMutationsVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startMutationsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addEnqueues(builder:flatbuffers.Builder, enqueuesOffset:flatbuffers.Offset) {
  builder.addFieldOffset(2, enqueuesOffset, 0);
}

static createEnqueuesVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startEnqueuesVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addDequeues(builder:flatbuffers.Builder, dequeuesOffset:flatbuffers.Offset) {
  builder.addFieldOffset(3, dequeuesOffset, 0);
}

static createDequeuesVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startDequeuesVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static endAtomicWrite(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  return offset;
}

static createAtomicWrite(builder:flatbuffers.Builder, checksOffset:flatbuffers.Offset, mutationsOffset:flatbuffers.Offset, enqueuesOffset:flatbuffers.Offset, dequeuesOffset:flatbuffers.Offset):flatbuffers.Offset {
  AtomicWrite.startAtomicWrite(builder);
  AtomicWrite.addChecks(builder, checksOffset);
  AtomicWrite.addMutations(builder, mutationsOffset);
  AtomicWrite.addEnqueues(builder, enqueuesOffset);
  AtomicWrite.addDequeues(builder, dequeuesOffset);
  return AtomicWrite.endAtomicWrite(builder);
}
}
